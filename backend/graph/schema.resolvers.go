package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
	"github.com/jefersonprimer/chatear/backend/graph/model"
	"github.com/jefersonprimer/chatear/backend/internal/user/application"
	"github.com/jefersonprimer/chatear/backend/shared/auth"
)

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, input model.RegisterUserInput) (*model.AuthResponse, error) {
	registerReq := application.RegisterUserRequest{
		Name:     input.Name,
		Email:    input.Email,
		Password: input.Password,
		Gender:   input.Gender.String(),
	}

	registerRes, err := r.Resolver.RegisterUserUseCase.Execute(ctx, registerReq)
	if err != nil {
		return nil, err
	}

	// After successful creation, fetch the user to return it
	user, err := r.Resolver.UserRepository.FindByID(ctx, uuid.MustParse(registerRes.UserID))
	if err != nil {
		return nil, err
	}

	accessToken, err := r.Resolver.TokenService.GenerateAccessToken(user.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to generate access token: %w", err)
	}

	newRefreshToken, err := r.Resolver.TokenService.GenerateRefreshToken(user.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to generate refresh token: %w", err)
	}

	return &model.AuthResponse{
		User:         toModelUser(user),
		AccessToken:  accessToken,
		RefreshToken: newRefreshToken,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthResponse, error) {
	loginReq := application.LoginRequest{
		Email:    input.Email,
		Password: input.Password,
	}

	loginOutput, err := r.Resolver.LoginUseCase.Execute(ctx, loginReq)
	if err != nil {
		return nil, err
	}

	return &model.AuthResponse{
		AccessToken:  loginOutput.AccessToken,
		RefreshToken: loginOutput.RefreshToken,
		User:         toModelUser(loginOutput.User),
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	accessToken, ok := ctx.Value(auth.ContextKeyAccessToken).(string)
	if !ok {
		// Handle the case where the access token is not in the context
		return false, nil
	}
	err := r.Resolver.LogoutUser.Execute(ctx, accessToken)
	if err != nil {
		return false, err
	}
	return true, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (bool, error) {
	resetReq := application.PasswordResetRequest{
		Email: input.Email,
	}

	err := r.Resolver.ResetPassword.Execute(ctx, resetReq)
	if err != nil {
		return false, err
	}

	return true, nil
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, input model.DeleteAccountInput) (bool, error) {
	deleteReq := application.DeleteUserRequest{
		UserID: input.UserID,
	}

	err := r.Resolver.DeleteUser.Execute(ctx, deleteReq)
	if err != nil {
		return false, err
	}

	return true, nil
}

// RecoverAccount is the resolver for the recoverAccount field.
func (r *mutationResolver) RecoverAccount(ctx context.Context, input model.RecoverAccountInput) (bool, error) {
	recoverReq := application.RecoverAccountRequest{
		Token:       input.Token,
		NewPassword: input.NewPassword,
	}

	err := r.Resolver.RecoverAccount.Execute(ctx, recoverReq)
	if err != nil {
		return false, err
	}

	return true, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, input model.VerifyEmailInput) (bool, error) {
	verifyReq := application.VerifyEmailRequest{
		Token: input.Token,
	}

	_, err := r.Resolver.VerifyEmailUseCase.Execute(ctx, verifyReq)
	if err != nil {
		return false, err
	}

	return true, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (*model.AuthResponse, error) {
	authTokens, err := r.Resolver.RefreshToken.Execute(ctx, input.RefreshToken)
	if err != nil {
		return nil, err
	}

	return &model.AuthResponse{AccessToken: authTokens.AccessToken, RefreshToken: authTokens.RefreshToken}, nil
}

// UploadAvatar is the resolver for the uploadAvatar field.
func (r *mutationResolver) UploadAvatar(ctx context.Context, file graphql.Upload) (string, error) {
	userID, err := auth.GetUserIDFromContext(ctx)
	if err != nil {
		return "", err
	}

	userEntity, err := r.Resolver.AvatarUsecases.UploadAvatar(ctx, userID, file.File)
	if err != nil {
		return "", err
	}

	if userEntity.AvatarURL != nil {
		return *userEntity.AvatarURL, nil
	}
	return "", nil
}

// DeleteAvatar is the resolver for the deleteAvatar field.
func (r *mutationResolver) DeleteAvatar(ctx context.Context) (bool, error) {
	userID, err := auth.GetUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	err = r.Resolver.AvatarUsecases.DeleteAvatar(ctx, userID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterUserInput) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Register - register"))
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	users, err := r.Resolver.GetUsersUseCase.GetUsers(ctx)
	if err != nil {
		return nil, err
	}

	var modelUsers []*model.User
	for _, user := range users {
		modelUsers = append(modelUsers, toModelUser(user))
	}

	return modelUsers, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, err := auth.GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.Resolver.UserRepository.FindByID(ctx, userID)
	if err != nil {
		return nil, err
	}

	return toModelUser(user), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
